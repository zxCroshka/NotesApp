## Содержание
1. [Введение](#введение)
2. [Архитектура проекта](#архитектура-проекта)
3. [Структура классов](#структура-классов)
4. [Оптимизации](#оптимизации)
6. [Руководство пользователя](#руководство-пользователя)

---

## Введение

### Назначение проекта
Программа для управления заметками с поддержкой различных типов контента: текстовые, графические, аудио и видео заметки. Предоставляет возможности быстрого поиска, фильтрации, сохранения и загрузки заметок.

### Требования к системе
- **Компилятор:** GCC 7+ / Clang 5+ / MSVC 2017+
- **Стандарт C++:** C++17 (рекомендуется C++20)
- **Оперативная память:** 256 МБ минимум
- **Дисковое пространство:** 10 МБ

### Особенности реализации
- Использование современных возможностей C++17/C++20
- Оптимизированные структуры данных для быстрого поиска
- Поддержка полиморфизма через наследование
- Сериализация данных в бинарный формат
- Модульная архитектура для легкого расширения

---

## Архитектура проекта

### Структура директорий
```
NotesProject/
├── include/              # Заголовочные файлы
│   ├── MediaContent.h   # Базовый класс контента
│   ├── TextContent.h    # Текстовый контент
│   ├── ImageContent.h   # Графический контент
│   ├── AudioContent.h   # Аудио контент
│   ├── VideoContent.h   # Видео контент
│   ├── Note.h          # Класс заметки
│   ├── NotesManager.h  # Менеджер заметок с индексами
│   ├── NoteFactory.h   # Фабрика для создания заметок
│   └── NotesApp.h      # Пользовательский интерфейс
├── src/                # Исходные файлы
│   ├── main.cpp       # Точка входа
│   ├── Note.cpp
│   ├── TextContent.cpp
│   ├── ImageContent.cpp
│   ├── AudioContent.cpp
│   ├── VideoContent.cpp
│   ├── NotesManager.cpp
│   ├── NoteFactory.cpp
│   └── NotesApp.cpp
├── CMakeLists.txt      # Файл сборки CMake
└── README.md          # Документация
```

### Принципы проектирования
1. **Принцип единственной ответственности** - каждый класс выполняет одну задачу
2. **Открытость/закрытость** - система открыта для расширения, но закрыта для модификации
3. **Принцип подстановки Лисков** - производные классы могут заменять базовые
4. **Инверсия зависимостей** - зависимости от абстракций, а не от реализаций

---

## Структура классов

### 1. MediaContent (Абстрактный базовый класс)

**Назначение:** Определяет интерфейс для всех типов контента.

**Почему абстрактный класс?**
- Позволяет реализовать полиморфизм
- Единый интерфейс для работы с разными типами контента
- Возможность легкого добавления новых типов

```cpp
class MediaContent {
public:
    virtual ~MediaContent() = default;
    virtual std::string getType() const = 0;
    virtual std::string getInfo() const = 0;
    virtual size_t getMemoryUsage() const = 0;
    virtual void save(std::ofstream& out) const = 0;
    virtual void load(std::ifstream& in) = 0;
};
```

### 2. TextContent, ImageContent, AudioContent, VideoContent

**Назначение:** Конкретные реализации типов контента.

**Особенности:**
- Наследуются от MediaContent
- Каждый класс хранит специфичные для типа данные
- Реализуют виртуальные методы базового класса

**Пример TextContent:**
```cpp
class TextContent : public MediaContent {
private:
    std::string text;  // Хранение текста
    
public:
    std::string getType() const override { return "text"; }
    std::string getInfo() const override {
        return "Текст (" + std::to_string(text.length()) + " символов)";
    }
    // ... другие методы
};
```

### 3. Note (Класс заметки)

**Назначение:** Представляет отдельную заметку со всеми атрибутами.

**Структура данных:**
```cpp
class Note {
private:
    std::string id;                    // Уникальный идентификатор
    std::string title;                 // Заголовок
    std::chrono::system_clock::time_point created;  // Дата создания
    std::chrono::system_clock::time_point modified; // Дата изменения
    std::set<std::string> tags;        // Теги (упорядоченное множество)
    std::unique_ptr<MediaContent> content;  // Контент (умный указатель)
};
```

**Почему такие структуры данных?**
- `std::set` для тегов: автоматическая сортировка, удаление дубликатов
- `std::unique_ptr` для контента: автоматическое управление памятью
- `std::chrono` для времени: точные временные метки

### 4. NotesManager (Менеджер заметок)

**Назначение:** Управление коллекцией заметок с индексацией для быстрого поиска.

**Ключевые структуры данных:**
```cpp
class NotesManager {
private:
    // Основное хранилище
    std::unordered_map<std::string, std::unique_ptr<Note>> notes;
    
    // Индексы для быстрого поиска
    std::unordered_map<std::string, std::unordered_set<std::string>> tagIndex;
    std::unordered_map<std::string, std::unordered_set<std::string>> typeIndex;
};
```

**Почему unordered_map/unordered_set?**
- **Средняя сложность O(1)** для поиска, вставки, удаления
- **Хэш-таблицы** быстрее деревьев для большинства операций
- **Идеально** для индексации по тегам и типам

### 5. NoteFactory (Фабрика заметок)

**Назначение:** Создание заметок разных типов.

**Паттерн:** Фабричный метод

**Преимущества:**
- Инкапсуляция логики создания
- Единая точка для создания объектов
- Легкое добавление новых типов заметок

### 6. NotesApp (Пользовательский интерфейс)

**Назначение:** Взаимодействие с пользователем через консоль.

**Реализация:** Паттерн MVC (Model-View-Controller)

---

## Оптимизации

### 1. Оптимизация производительности

#### a) Индексация для быстрого поиска
```cpp
// Создание индекса при добавлении заметки
void NotesManager::updateIndexes(const std::string& id) {
    Note* note = notes[id].get();
    
    // Индекс по тегам
    for (const auto& tag : note->getTags()) {
        tagIndex[tag].insert(id);  // O(1) в среднем
    }
    
    // Индекс по типам
    if (note->getContent()) {
        typeIndex[note->getContent()->getType()].insert(id);
    }
}
```

**Сложность операций:**
- Добавление заметки: **O(k + m)** где k - количество тегов, m = O(1)
- Поиск по тегу: **O(1)** в среднем
- Поиск по типу: **O(1)** в среднем
- Поиск по нескольким тегам: **O(min(n1, n2, ...))**

#### b) Оптимизация памяти
- Использование `std::unique_ptr` для предотвращения утечек памяти
- Хранение строк по значению (SSO - Small String Optimization)
- Использование `std::string_view` где возможно (C++17)

#### c) Move-семантика
```cpp
Note::Note(const std::string& title, std::unique_ptr<MediaContent> content)
    : title(title), content(std::move(content)) {  // Move вместо копирования
    // ...
}
```

### 2. Алгоритмические оптимизации

#### Поиск по нескольким тегам:
```cpp
std::vector<Note*> NotesManager::searchByTags(const std::vector<std::string>& tags) {
    // Начинаем с первого тега
    std::unordered_set<std::string> result = tagIndex[tags[0]];
    
    // Пересечение с остальными тегами
    for (size_t i = 1; i < tags.size(); ++i) {
        std::unordered_set<std::string> intersection;
        for (const auto& id : tagIndex[tags[i]]) {
            if (result.find(id) != result.end()) {
                intersection.insert(id);
            }
        }
        result = std::move(intersection);  // Move вместо копирования
    }
    
    // Преобразование результата
    // ...
}
```

**Оптимизация:** Используется минимальное множество для пересечения

### 3. Сериализация

**Формат хранения:**
```
[количество заметок: size_t]
[заметка 1]
[заметка 2]
...
```

**Оптимизации сериализации:**
- Бинарный формат (меньше места, быстрее чтение/запись)
- Сохранение размеров строк перед данными
- Использование `reinterpret_cast` для POD-типов

---

## Руководство пользователя

### Установка и запуск

#### Компиляция:
```bash
mkdir build
cd build
cmake ..
make
./NotesApp
```


### Основные функции

#### 1. Создание заметки
```
Меню → 1. Создать заметку
Выберите тип: 1-4
Введите заголовок
Введите содержимое
Добавьте теги (через запятую)
```

#### 2. Поиск заметок
```
Меню → 3. Поиск по тегу
Введите тег: работа

Меню → 4. Поиск по типу
Выберите тип: 1-4
```

#### 3. Редактирование заметок
```
Меню → 2. Просмотреть все заметки
Меню → 5. Редактировать заметку
Выберите номер заметки
Измените заголовок или теги
```

### Сохранение данных
- Данные автоматически сохраняются в `notes.dat`
- Ручное сохранение при выходе из программы
- Бинарный формат для скорости и компактности

---
### Профилирование и оптимизация

#### Типичные оптимизации:
1. Замена `std::map` на `std::unordered_map` где порядок не важен
2. Использование `reserve()` для заранее известного размера
3. Замена копирования на перемещение
4. Использование string_view для передачи строк

### Советы по коду

#### 1. Использование умных указателей
```cpp
// Правильно
std::unique_ptr<Note> note = std::make_unique<Note>();

// Неправильно
Note* note = new Note();
```

#### 2. Move-семантика
```cpp
void addNote(std::unique_ptr<Note> note) {
    notes[note->getId()] = std::move(note);  // Move, а не копирование
}
```

#### 3. Const-корректность
```cpp
const std::string& getTitle() const;  // Константный метод
```

#### 4. Исключения
```cpp
try {
    manager.loadFromFile(filename);
} catch (const std::exception& e) {
    std::cerr << "Ошибка: " << e.what() << std::endl;
}
```

---

## Заключение


### Ключевые технологии
- **C++17/C++20** - современный стандарт
- **CMake** - система сборки
- **Catch2** - фреймворк тестирования
- **STL** - стандартная библиотека шаблонов
- **Хэш-таблицы** - быстрый поиск O(1)
